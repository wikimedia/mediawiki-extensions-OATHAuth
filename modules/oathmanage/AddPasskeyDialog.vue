<template>
	<cdx-dialog
		v-model:open="wrappedOpen"
		class="mw-oathauth-passkeydialog"
		:title="$i18n( 'oathauth-passkey-dialog-title' )"
		:primary-action="primaryAction"
		:default-action="defaultAction"
		@primary="createPasskey"
		@default="close"
	>
		<template #header>
			<div class="mw-oathauth-passkeydialog__image"></div>
			<h2 class="cdx-dialog__header__title">
				{{ $i18n( 'oathauth-passkey-dialog-title' ) }}
			</h2>
		</template>

		<!-- v-html is safe because this data is generated by the server-side wikitext parser -->
		<!-- eslint-disable-next-line vue/no-v-html -->
		<div v-html="passkeyDialogTextHtml"></div>

		<template v-if="errorMessage" #footer-text>
			<cdx-message type="error">
				{{ errorMessage }}
			</cdx-message>
		</template>
	</cdx-dialog>
	<!-- HACK: form mimicking WebAuthnAddKeyForm, replace this with an API endpoint -->
	<form
		ref="form"
		:action="formAction"
		method="POST"
	>
		<input
			v-for="( value, name ) in formFields"
			:key="name"
			type="hidden"
			:name="name"
			:value="value"
		>
	</form>
</template>

<script>
const { defineComponent, ref, reactive, toRef, useTemplateRef, nextTick } = require( 'vue' );
const { CdxDialog, CdxMessage, useModelWrapper } = require( './codex.js' );
const { passkeyDialogTextHtml } = require( './data.json' );

module.exports = exports = defineComponent( {
	components: {
		CdxDialog,
		CdxMessage
	},
	props: {
		open: {
			type: Boolean,
			default: false
		}
	},
	setup( props, { emit } ) {
		const wrappedOpen = useModelWrapper( toRef( () => props.open ), emit, 'update:open' );
		const form = useTemplateRef( 'form' );
		const errorMessage = ref( '' );
		const formAction = mw.config.get( 'wgScript' );
		const formFields = reactive( {
			title: mw.config.get( 'wgPageName' ),
			wpEditToken: mw.user.tokens.get( 'csrfToken' ),
			module: 'webauthn',
			action: 'enable',
			passkeyMode: '1',
			credential: ''
		} );
		const primaryAction = {
			label: mw.msg( 'oathauth-passkey-dialog-add' ),
			actionType: 'progressive'
		};
		const defaultAction = {
			label: mw.msg( 'oathauth-passkey-dialog-back' )
		};

		function createPasskey() {
			// TODO we can't directly depend on ext.webauthn.Registrator because the OATHAuth
			// extension can't depend on the WebAuthn extension. This should be resolved by
			// merging the two extensions (T303495)
			mw.loader.using( 'ext.webauthn.Registrator' ).then( () => {
				// FIXME we should not hard-code 'Passkey', but instead generate a name in the API
				const registrator = new mw.ext.webauthn.Registrator( 'Passkey', null, true );
				return registrator.register();
			} ).then(
				( credential ) => {
					// HACK: for now, create a form that mimicks WebAuthnAddKeyForm and submit it
					// But really this should use an api.php endpoint via mw.Api()
					formFields.credential = JSON.stringify( credential );

					// Wait for Vue to update the form fields in the DOM before submitting the form,
					// otherwise the updated credential is not submitted
					nextTick( () => {
						form.value.submit();
					} );
				},
				( error ) => {
					errorMessage.value = mw.message( error ).exists() ?
						mw.message( error ).text() :
						error;
				}
			);
		}

		function close() {
			wrappedOpen.value = false;
			errorMessage.value = '';
		}

		return {
			wrappedOpen,
			primaryAction,
			defaultAction,
			createPasskey,
			close,
			passkeyDialogTextHtml,
			errorMessage,
			formAction,
			formFields
		};
	}
} );
</script>

<style lang="less">
@import 'mediawiki.skin.variables';

.mw-oathauth-passkeydialog {
	&__image {
		width: @size-800;
		height: @size-800;
		margin-left: auto;
		margin-right: auto;
		background: url( passkey.svg ) no-repeat center;
	}
}
</style>
